//@version=6
indicator("Options Open Interest Visualization", "Options OI", overlay=true, max_lines_count=500, max_labels_count=500)

// Input parameters
expirationDateInput = input.string(title="Expiration Date (YYYY-MM-DD)", defval="2025-05-16", tooltip="Format: YYYY-MM-DD")
rangeAboveBelowInput = input.int(title="Strike Range Above/Below Spot", defval=100, minval=10, maxval=500)
stepSizeInput = input.float(title="Strike Price Step Size", defval=5.0, minval=0.5, maxval=25.0)
maxDisplayedStrikesInput = input.int(title="Max Displayed Strikes", defval=20, minval=5, maxval=50)
barWidthFactorInput = input.float(title="Bar Width Factor", defval=0.5, minval=0.1, maxval=5.0, step=0.1)
showCallsInput = input.bool(title="Show Calls", defval=true)
showPutsInput = input.bool(title="Show Puts", defval=true)
linewidthInput = input.int(title="Line Width", defval=2, minval=1, maxval=10)
callsColorInput = input.color(color.green, "Calls Color")
putsColorInput = input.color(color.red, "Puts Color")
minBarSizeInput = input.float(title="Minimum Bar Size (% of screen)", defval=1.0, minval=0.1, maxval=5.0)
maxBarSizeInput = input.float(title="Maximum Bar Size (% of screen)", defval=20.0, minval=5.0, maxval=50.0)
showLabelsInput = input.bool(title="Show Strike Labels", defval=true)
showOpenInterestValuesInput = input.bool(title="Show Open Interest Values", defval=true)
positionLabelsInput = input.string("Left", "Labels Position", options=["Left", "Right"])
oiScalingInput = input.string("Logarithmic", "Open Interest Scaling", options=["Linear", "Logarithmic"])

// Define a custom type for the OI graphics
type oiGraphic
    line barLine
    label infoLabel
    float strikePrice
    int openInterest
    bool isCall

// Function to delete graphics
method delete(oiGraphic graphic) =>
    graphic.barLine.delete()
    graphic.infoLabel.delete()

// Matrix to store drawn graphics
var drawnGraphics = matrix.new<oiGraphic>()

// Function to get simulated open interest data
// In a real implementation, this would be fetched via request.security or external data
getOpenInterest(strikePrice, isCall, expirationDate) =>
    // This is a simulation function - replace with actual data fetching
    // For demonstration, we'll generate values with higher OI near ATM and lower OI farther away
    spotPrice = close
    distance = math.abs(strikePrice - spotPrice)
    baseOI = isCall ? 
        math.max(10000 * (1 - distance / (2 * rangeAboveBelowInput)), 500) : 
        math.max(10000 * (1 - distance / (2 * rangeAboveBelowInput)), 500)
    
    // Add some randomness
    randomFactor = math.random() * 0.4 + 0.8
    
    // Create spikes at key levels
    spikeAtRound = strikePrice % 50 == 0 ? 2.5 : 1.0
    spikeAtHalf = strikePrice % 25 == 0 ? 1.5 : 1.0
    
    // Generate final OI value
    int(baseOI * randomFactor * spikeAtRound * spikeAtHalf)

// Function to scale the open interest value to a bar width
scaleOpenInterest(openInterest, maxOI) =>
    chartWidth = timeframe.in_seconds() * 1000 * barWidthFactorInput
    
    // Determine the scaling method
    scaledValue = switch oiScalingInput
        "Linear" => openInterest / maxOI
        "Logarithmic" => math.log(openInterest + 1) / math.log(maxOI + 1)
        => openInterest / maxOI  // Default to linear
        
    // Apply min/max constraints
    minSize = minBarSizeInput / 100 * chartWidth
    maxSize = maxBarSizeInput / 100 * chartWidth
    
    math.max(minSize, math.min(maxSize, scaledValue * chartWidth))

// Function to draw new OI bars
drawOpenInterestBars(currentTime) =>
    // Clear previous graphics if needed
    if drawnGraphics.rows() > 0
        oldGraphics = drawnGraphics.remove_row(0)
        for graphic in oldGraphics
            graphic.delete()
    
    newGraphics = array.new<oiGraphic>()
    spotPrice = close
    
    // Calculate strike prices to display
    var callStrikes = array.new<float>()
    var putStrikes = array.new<float>()
    array.clear(callStrikes)
    array.clear(putStrikes)
    
    // Generate call strikes (above spot)
    startCallStrike = math.ceil(spotPrice / stepSizeInput) * stepSizeInput
    for i = 0 to maxDisplayedStrikesInput - 1
        strike = startCallStrike + i * stepSizeInput
        if strike <= spotPrice + rangeAboveBelowInput
            array.push(callStrikes, strike)
    
    // Generate put strikes (below spot)
    startPutStrike = math.floor(spotPrice / stepSizeInput) * stepSizeInput
    for i = 0 to maxDisplayedStrikesInput - 1
        strike = startPutStrike - i * stepSizeInput
        if strike >= spotPrice - rangeAboveBelowInput
            array.push(putStrikes, strike)
    
    // Get max open interest value for scaling
    var maxOI = 0
    
    // Process call strikes
    if showCallsInput
        for strike in callStrikes
            oi = getOpenInterest(strike, true, expirationDateInput)
            maxOI := math.max(maxOI, oi)
    
    // Process put strikes
    if showPutsInput
        for strike in putStrikes
            oi = getOpenInterest(strike, false, expirationDateInput)
            maxOI := math.max(maxOI, oi)
    
    // Draw call bars
    if showCallsInput
        for strike in callStrikes
            oi = getOpenInterest(strike, true, expirationDateInput)
            barWidth = scaleOpenInterest(oi, maxOI)
            
            lineEndTime = currentTime + timeframe.in_seconds() * 1000
            barLine = line.new(
                x1=currentTime, 
                y1=strike, 
                x2=currentTime + barWidth, 
                y2=strike, 
                xloc=xloc.bar_time, 
                color=callsColorInput, 
                width=linewidthInput,
                style=line.style_solid)
            
            // Create label
            labelText = ""
            if showLabelsInput
                labelText := str.tostring(strike, format.mintick) + " "
            if showOpenInterestValuesInput
                labelText := labelText + "(" + str.tostring(oi, format="#,##0") + ")"
                
            infoLabel = label.new(
                x=positionLabelsInput == "Left" ? currentTime : currentTime + barWidth,
                y=strike,
                text=labelText,
                style=positionLabelsInput == "Left" ? label.style_label_right : label.style_label_left,
                textcolor=callsColorInput,
                color=#00000000,
                xloc=xloc.bar_time)
                
            newGraphics.push(oiGraphic.new(barLine, infoLabel, strike, oi, true))
    
    // Draw put bars
    if showPutsInput
        for strike in putStrikes
            oi = getOpenInterest(strike, false, expirationDateInput)
            barWidth = scaleOpenInterest(oi, maxOI)
            
            lineEndTime = currentTime + timeframe.in_seconds() * 1000
            barLine = line.new(
                x1=currentTime, 
                y1=strike, 
                x2=currentTime - barWidth, 
                y2=strike, 
                xloc=xloc.bar_time, 
                color=putsColorInput, 
                width=linewidthInput,
                style=line.style_solid)
            
            // Create label
            labelText = ""
            if showLabelsInput
                labelText := str.tostring(strike, format.mintick) + " "
            if showOpenInterestValuesInput
                labelText := labelText + "(" + str.tostring(oi, format="#,##0") + ")"
                
            infoLabel = label.new(
                x=positionLabelsInput == "Left" ? currentTime : currentTime - barWidth,
                y=strike,
                text=labelText,
                style=positionLabelsInput == "Left" ? label.style_label_right : label.style_label_left,
                textcolor=putsColorInput,
                color=#00000000,
                xloc=xloc.bar_time)
                
            newGraphics.push(oiGraphic.new(barLine, infoLabel, strike, oi, false))
    
    drawnGraphics.add_row(array_id = newGraphics)

// Variables to track when to update
var lastCalculationDate = 0
var calculatedToday = false

// Update conditions
newDay = dayofmonth != dayofmonth[1]
initialLoad = barstate.isfirst

// Main execution logic
if initialLoad or (newDay and not calculatedToday)
    calculatedToday := true
    lastCalculationDate := dayofmonth
    drawOpenInterestBars(time)

if newDay
    calculatedToday := false

// Add note about simulated data
if barstate.islast
    label.new(
        bar_index, low, 
        text="Note: This indicator uses simulated open interest data.\nIn production, connect to actual options data.",
        style=label.style_label_up,
        color=color.gray,
        textcolor=color.white,
        size=size.small)
